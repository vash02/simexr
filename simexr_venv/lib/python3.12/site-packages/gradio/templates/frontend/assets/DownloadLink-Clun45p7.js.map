{"version":3,"file":"DownloadLink-Clun45p7.js","sources":["../../../../js/wasm/svelte/context.ts","../../../../js/wasm/network/host.ts","../../../../js/wasm/src/http.ts","../../../../js/wasm/svelte/file-url.ts","../../../../js/wasm/svelte/DownloadLink.svelte"],"sourcesContent":["import { setContext, getContext } from \"svelte\";\nimport type { WorkerProxy } from \"../src/worker-proxy\";\n\nconst WORKER_PROXY_CONTEXT_KEY = \"WORKER_PROXY_CONTEXT_KEY\";\n\nexport function setWorkerProxyContext(workerProxy: WorkerProxy): void {\n\tsetContext(WORKER_PROXY_CONTEXT_KEY, workerProxy);\n}\n\nexport function getWorkerProxyContext(): WorkerProxy | undefined {\n\treturn getContext(WORKER_PROXY_CONTEXT_KEY);\n}\n","// A special hostname representing the Lite's server.\n// For example, when the endpoint is a local file (`file:/*`), the host name is set to this value (ref: determine_protocol() in client/js/src/helpers/init_helpers.ts)\nexport const FAKE_LITE_HOST = \"lite.local\";\n\nexport function is_self_host(url: URL): boolean {\n\treturn (\n\t\turl.host === window.location.host ||\n\t\turl.host === \"localhost:7860\" ||\n\t\turl.host === \"127.0.0.1:7860\" || // Ref: https://github.com/gradio-app/gradio/blob/v3.32.0/js/app/src/Index.svelte#L194\n\t\turl.host === FAKE_LITE_HOST\n\t);\n}\n","export interface HttpRequest {\n\tmethod: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\";\n\tpath: string;\n\tquery_string: string; // This field must not contain the leading `?`, as it's directly used in the ASGI spec which requires this.\n\theaders: Record<string, string>;\n\tbody?: Uint8Array | ReadableStream<Uint8Array> | null;\n}\nexport interface HttpResponse {\n\tstatus: number;\n\theaders: Record<string, string>;\n\tbody: Uint8Array;\n}\n\n// Inspired by https://github.com/rstudio/shinylive/blob/v0.1.2/src/messageporthttp.ts\nexport function headersToASGI(\n\theaders: HttpRequest[\"headers\"]\n): [string, string][] {\n\tconst result: [string, string][] = [];\n\tfor (const [key, value] of Object.entries(headers)) {\n\t\tresult.push([key, value]);\n\t}\n\treturn result;\n}\n\nexport function uint8ArrayToString(buf: Uint8Array): string {\n\tlet result = \"\";\n\tfor (let i = 0; i < buf.length; i++) {\n\t\tresult += String.fromCharCode(buf[i]);\n\t}\n\treturn result;\n}\n\nexport function asgiHeadersToRecord(headers: any): Record<string, string> {\n\theaders = headers.map(([key, val]: [Uint8Array, Uint8Array]) => {\n\t\treturn [uint8ArrayToString(key), uint8ArrayToString(val)];\n\t});\n\treturn Object.fromEntries(headers);\n}\n\nexport function getHeaderValue(\n\theaders: HttpRequest[\"headers\"],\n\tkey: string\n): string | undefined {\n\t// The keys in `headers` are case-insensitive.\n\tconst unifiedKey = key.toLowerCase();\n\tfor (const [k, v] of Object.entries(headers)) {\n\t\tif (k.toLowerCase() === unifiedKey) {\n\t\t\treturn v;\n\t\t}\n\t}\n}\n\nexport function logHttpReqRes(\n\trequest: HttpRequest,\n\tresponse: HttpResponse\n): void {\n\tif (Math.floor(response.status / 100) !== 2) {\n\t\tlet bodyText: string;\n\t\tlet bodyJson: unknown;\n\t\ttry {\n\t\t\tbodyText = new TextDecoder().decode(response.body);\n\t\t} catch (e) {\n\t\t\tbodyText = \"(failed to decode body)\";\n\t\t}\n\t\ttry {\n\t\t\tbodyJson = JSON.parse(bodyText);\n\t\t} catch (e) {\n\t\t\tbodyJson = \"(failed to parse body as JSON)\";\n\t\t}\n\t\tconsole.error(\"Wasm HTTP error\", {\n\t\t\trequest,\n\t\t\tresponse,\n\t\t\tbodyText,\n\t\t\tbodyJson\n\t\t});\n\t}\n}\n","import { getWorkerProxyContext } from \"./context\";\nimport { is_self_host } from \"../network/host\";\nimport { getHeaderValue } from \"../src/http\";\nimport type { WorkerProxy } from \"../src/worker-proxy\";\n\ntype MediaSrc = string | undefined | null;\n\nexport function should_proxy_wasm_src(src: MediaSrc): boolean {\n\tconst is_browser = typeof window !== \"undefined\";\n\n\tif (src == null || !is_browser) {\n\t\treturn false;\n\t}\n\n\tconst url = new URL(src, window.location.href);\n\tif (!is_self_host(url)) {\n\t\t// `src` is not accessing a local server resource, so we don't need to proxy this request to the Wasm worker.\n\t\treturn false;\n\t}\n\tif (url.protocol !== \"http:\" && url.protocol !== \"https:\") {\n\t\t// `src` can be a data URL.\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nlet maybeWorkerProxy: WorkerProxy | undefined;\n\nexport async function resolve_wasm_src(src: MediaSrc): Promise<MediaSrc> {\n\tconst is_browser = typeof window !== \"undefined\";\n\tif (src == null || !is_browser || !should_proxy_wasm_src(src)) {\n\t\treturn src;\n\t}\n\n\tif (maybeWorkerProxy == null) {\n\t\ttry {\n\t\t\tmaybeWorkerProxy = getWorkerProxyContext();\n\t\t} catch (e) {\n\t\t\t// We are not in the Wasm env. Just use the src as is.\n\t\t\treturn src;\n\t\t}\n\t}\n\n\tif (maybeWorkerProxy == null) {\n\t\t// We are not in the Wasm env. Just use the src as is.\n\t\treturn src;\n\t}\n\n\tconst url = new URL(src, window.location.href);\n\tconst path = url.pathname;\n\treturn maybeWorkerProxy\n\t\t.httpRequest({\n\t\t\tmethod: \"GET\",\n\t\t\tpath,\n\t\t\theaders: {},\n\t\t\tquery_string: \"\"\n\t\t})\n\t\t.then((response) => {\n\t\t\tif (response.status !== 200) {\n\t\t\t\tthrow new Error(`Failed to get file ${path} from the Wasm worker.`);\n\t\t\t}\n\t\t\tconst blob = new Blob([response.body], {\n\t\t\t\ttype: getHeaderValue(response.headers, \"content-type\")\n\t\t\t});\n\t\t\tconst blobUrl = URL.createObjectURL(blob);\n\t\t\treturn blobUrl;\n\t\t});\n}\n","<script lang=\"ts\">\n\timport type { HTMLAnchorAttributes } from \"svelte/elements\";\n\timport { createEventDispatcher, onMount } from \"svelte\";\n\n\tinterface DownloadLinkAttributes\n\t\textends Omit<HTMLAnchorAttributes, \"target\"> {\n\t\tdownload: NonNullable<HTMLAnchorAttributes[\"download\"]>;\n\t}\n\ttype $$Props = DownloadLinkAttributes;\n\n\timport { getWorkerProxyContext } from \"./context\";\n\timport { should_proxy_wasm_src } from \"./file-url\";\n\timport { getHeaderValue } from \"../src/http\";\n\n\texport let href: DownloadLinkAttributes[\"href\"] = undefined;\n\texport let download: DownloadLinkAttributes[\"download\"];\n\n\tconst dispatch = createEventDispatcher();\n\n\tlet is_downloading = false;\n\tconst worker_proxy = getWorkerProxyContext();\n\tasync function wasm_click_handler(): Promise<void> {\n\t\tif (is_downloading) {\n\t\t\treturn;\n\t\t}\n\n\t\tdispatch(\"click\");\n\n\t\tif (href == null) {\n\t\t\tthrow new Error(\"href is not defined.\");\n\t\t}\n\t\tif (worker_proxy == null) {\n\t\t\tthrow new Error(\"Wasm worker proxy is not available.\");\n\t\t}\n\n\t\tconst url = new URL(href, window.location.href);\n\t\tconst path = url.pathname;\n\n\t\tis_downloading = true;\n\t\tworker_proxy\n\t\t\t.httpRequest({\n\t\t\t\tmethod: \"GET\",\n\t\t\t\tpath,\n\t\t\t\theaders: {},\n\t\t\t\tquery_string: \"\"\n\t\t\t})\n\t\t\t.then((response) => {\n\t\t\t\tif (response.status !== 200) {\n\t\t\t\t\tthrow new Error(`Failed to get file ${path} from the Wasm worker.`);\n\t\t\t\t}\n\t\t\t\tconst blob = new Blob([response.body], {\n\t\t\t\t\ttype: getHeaderValue(response.headers, \"content-type\")\n\t\t\t\t});\n\t\t\t\tconst blobUrl = URL.createObjectURL(blob);\n\n\t\t\t\tconst link = document.createElement(\"a\");\n\t\t\t\tlink.href = blobUrl;\n\t\t\t\tlink.download = download;\n\t\t\t\tlink.click();\n\n\t\t\t\tURL.revokeObjectURL(blobUrl);\n\t\t\t})\n\t\t\t.finally(() => {\n\t\t\t\tis_downloading = false;\n\t\t\t});\n\t}\n</script>\n\n{#if worker_proxy && should_proxy_wasm_src(href)}\n\t{#if is_downloading}\n\t\t<slot />\n\t{:else}\n\t\t<a {...$$restProps} {href} on:click|preventDefault={wasm_click_handler}>\n\t\t\t<slot />\n\t\t</a>\n\t{/if}\n{:else}\n\t<a\n\t\tstyle:position=\"relative\"\n\t\tclass=\"download-link\"\n\t\t{href}\n\t\ttarget={typeof window !== \"undefined\" && window.__is_colab__\n\t\t\t? \"_blank\"\n\t\t\t: null}\n\t\trel=\"noopener noreferrer\"\n\t\t{download}\n\t\t{...$$restProps}\n\t\ton:click={dispatch.bind(null, \"click\")}\n\t>\n\t\t<slot />\n\t</a>\n{/if}\n\n<style>\n\t.unstyled-link {\n\t\tall: unset;\n\t\tcursor: pointer;\n\t}\n</style>\n"],"names":["setContext","WORKER_PROXY_CONTEXT_KEY","setWorkerProxyContext","workerProxy","getWorkerProxyContext","getContext","FAKE_LITE_HOST","is_self_host","url","getHeaderValue","headers","key","unifiedKey","k","v","should_proxy_wasm_src","src","is_browser","maybeWorkerProxy","resolve_wasm_src","path","response","blob","createEventDispatcher","onMount","a_target_value","ctx","insert","target","a","anchor","dispose","listen","href","$$props","download","dispatch","is_downloading","worker_proxy","wasm_click_handler","blobUrl","link"],"mappings":"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"}